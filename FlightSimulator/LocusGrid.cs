// FrontEnd Plus GUI for JAD
// DeCompiled : LocusGrid.class

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
// 11/05/19 19:45    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
namespace FlightSimulator
{
    using Jp.Maker1.Vsys3.Tools;
    using System;
    using System.Drawing;
    using System.Collections;
    using System.ComponentModel;
    using System.IO;
    using System.Runtime.CompilerServices;

    public class LocusGrid
    {

        private Color groundGridCol;
        private Color groundcCol;
        private Color yBaseGridCol;
        private Color yBaseCol;
        private Color strCol;
        public Font stdFont;
        public Font smallFont;
        public VsObject grid;
        public double grid_scale;
        internal double xs;
        internal double xe;
        internal double zs;
        internal double ze;
        internal double ys;

        public LocusGrid()
        {
            groundGridCol = Color.FromArgb(200, 200, 200);
            groundcCol = Color.FromArgb(240, 240, 240);
            yBaseGridCol = Color.FromArgb(200, 200, 200);
            yBaseCol = Color.FromArgb(250, 250, 250);
            strCol = Color.FromArgb(128, 128, 128);
            stdFont = new Font("SansSelif", 12);
            smallFont = new Font("SansSelif", 10);
            grid = new VsObject();
        }

        public VsObject MakeGrid(BoundingBox bbox, double dist, double viewAngle)
        {
            double range_base = bbox.XSize();
            if (range_base < bbox.ZSize())
                range_base = bbox.ZSize();
            double k = dist / (bbox.DiagonalSize() / 2D / System.Math.Tan(MathTool.DegToRad(viewAngle) / 2D));
            range_base *= k;
            grid_scale = Kizami(range_base);
            if (grid_scale < 50D)
                grid_scale = 50D;
            xs = Start(bbox.GetMinX() - 10D, grid_scale);
            xe = End(bbox.GetMaxX() + 10D, grid_scale);
            zs = Start(bbox.GetMinZ() - 10D, grid_scale);
            ze = End(bbox.GetMaxZ() + 10D, grid_scale);
            ys = Y_base(bbox);
            Vector3D v1 = new Vector3D(xs, 0.0D, zs);
            Vector3D v2 = new Vector3D(xe, 0.0D, zs);
            Vector3D v3 = new Vector3D(xe, 0.0D, ze);
            Vector3D v4 = new Vector3D(xs, 0.0D, ze);
            Vector3D v5 = new Vector3D(xs, ys, zs);
            Vector3D v6 = new Vector3D(xe, ys, zs);
            Vector3D v7 = new Vector3D(xe, ys, ze);
            Vector3D v8 = new Vector3D(xs, ys, ze);
            VsPolygon groundPol = new VsPolygon();
            groundPol.col = groundcCol;
            groundPol.pol.AddVertex(v1);
            groundPol.pol.AddVertex(v2);
            groundPol.pol.AddVertex(v3);
            groundPol.pol.AddVertex(v4);
            grid = new VsObject();
            grid.Add(groundPol);
            grid.Add(Jp.Maker1.Vsys3.Tools.BasicObject.XzGlid(0.0D, xs, zs, xe, ze, grid_scale, grid_scale, groundGridCol));
            if (ys > 0.0D)
            {
                grid.Add(new VsSegment(v1, v5, yBaseGridCol));
                grid.Add(new VsSegment(v2, v6, yBaseGridCol));
                grid.Add(new VsSegment(v3, v7, yBaseGridCol));
                grid.Add(new VsSegment(v4, v8, yBaseGridCol));
                VsPolygon basePol = new VsPolygon();
                basePol.col = yBaseCol;
                basePol.pol.AddVertex(v5);
                basePol.pol.AddVertex(v6);
                basePol.pol.AddVertex(v7);
                basePol.pol.AddVertex(v8);
                grid.Add(basePol);
                grid.Add(Jp.Maker1.Vsys3.Tools.BasicObject.XzGlid(ys, xs, zs, xe, ze, grid_scale,
                        grid_scale, yBaseGridCol));
            }
            grid.Add(new VsString(DispFormat.DoubleFormat(ys, 0) + "m", v5, Color.Gray, smallFont));
            grid.Add(new VsString(DispFormat.DoubleFormat(ys, 0) + "m", v6, Color.Gray, smallFont));
            grid.Add(new VsString(DispFormat.DoubleFormat(ys, 0) + "m", v7, Color.Gray, smallFont));
            grid.Add(new VsString(DispFormat.DoubleFormat(ys, 0) + "m", v8, Color.Gray, smallFont));
            grid.Add(new VsString("NORTH", v7.Add(v8).SclProd(0.5D), Color.Gray, smallFont));
            grid.Add(new VsString("SOUTH", v5.Add(v6).SclProd(0.5D), Color.Gray, smallFont));
            grid.Add(new VsString("WEST", v8.Add(v5).SclProd(0.5D), Color.Gray, smallFont));
            grid.Add(new VsString("EAST", v7.Add(v6).SclProd(0.5D), Color.Gray, smallFont));
            return grid;
        }

        static internal double Y_base(BoundingBox bbox)
        {
            double n = Math.Floor((bbox.GetMinY() - 20D) / 10D);
            double yb = n * 10D;
            if (yb < 10D)
                yb = 0.0D;
            return yb;
        }

        public static double Kizami(double haba)
        {
            if (haba < 20D)
                haba = 20D;
            double logbase = Math.Ceiling(MathTool.Log10(haba));
            double haba_base = Math.Pow(10D, logbase);
            double ret;
            if (haba_base >= haba * 5D)
                ret = haba_base / 5D / 4D;
            else if (haba_base >= haba * 2D)
                ret = haba_base / 2D / 5D;
            else
                ret = haba_base / 1.0D / 5D;
            return ret;
        }

        public static double Start(double x, double kizami)
        {
            return Math.Floor(x / kizami) * kizami;
        }

        public static double End(double x, double kizami)
        {
            return Math.Ceiling(x / kizami) * kizami;
        }
    }
}