// FrontEnd Plus GUI for JAD
// DeCompiled : Clipper.class

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
// 11/05/19 19:45    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
namespace Jp.Maker1.Vsys3.Tools
{

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.IO;
    using System.Runtime.CompilerServices;

    // Referenced classes of package jp.maker1.vsys3.tools:
    //            Projector, Segment3D, Vector3D, Polygon3D

    public class Clipper
    {

        public double vp_xmin;
        public double vp_ymin;
        public double vp_xmax;
        public double vp_ymax;
        public readonly double VSLIB_CLIP_ZMIN;

        public Clipper()
        {
            VSLIB_CLIP_ZMIN = 0.10000000000000001D;
            vp_xmin = 0.0D;
            vp_ymin = 0.0D;
            vp_xmax = 299D;
            vp_ymax = 299D;
        }

        public Clipper(double x0, double y0, double x1, double y1)
        {
            VSLIB_CLIP_ZMIN = 0.10000000000000001D;
            vp_xmin = x0;
            vp_ymin = y0;
            vp_xmax = x1;
            vp_ymax = y1;
        }

        public Clipper(Projector proj)
        {
            VSLIB_CLIP_ZMIN = 0.10000000000000001D;
            vp_xmin = 0.0D;
            vp_ymin = 0.0D;
            vp_xmax = proj.screenXSize - 1.0D;
            vp_ymax = proj.screenYSize - 1.0D;
        }

        private int Make_4bit_code(double x, double y, double cx1, double cy1,
                double cx2, double cy2)
        {
            int c = 0;
            if (x < cx1)
                c = 1;
            if (x > cx2)
                c = 2;
            if (y < cy1)
                c += 4;
            if (y > cy2)
                c += 8;
            return c;
        }

        public Segment3D Vs_line_clip_2d(Segment3D org)
        {
            Segment3D ret = new Segment3D();
            double y;
            double x = y = 0.0D;
            double cx1 = vp_xmin - 0.4D;
            double cy1 = vp_ymin - 0.4D;
            double cx2 = vp_xmax + 0.4D;
            double cy2 = vp_ymax + 0.4D;
            double x1 = org.p0.x;
            double y1 = org.p0.y;
            double x2 = org.p1.x;
            double y2 = org.p1.y;
            int c1 = Make_4bit_code(x1, y1, cx1, cy1, cx2, cy2);
            int c2 = Make_4bit_code(x2, y2, cx1, cy1, cx2, cy2);
            for (int i = 0; i < 100; i++)
            {
                if ((c1 | c2) == 0)
                {
                    ret.p0.x = x1;
                    ret.p0.y = y1;
                    ret.p0.z = 0.0D;
                    ret.p1.x = x2;
                    ret.p1.y = y2;
                    ret.p1.z = 0.0D;
                    return ret;
                }
                if ((c1 & c2) != 0)
                    return null;
                int c;
                if (c1 != 0)
                    c = c1;
                else
                    c = c2;
                if (x1 == x2)
                {
                    if (y2 < cy1)
                        y = cy1;
                    else if (y2 > cy2)
                        y = cy2;
                    if (y1 < cy1)
                        y = cy1;
                    else if (y1 > cy2)
                        y = cy2;
                    x = x1;
                }
                else if ((c & 1) != 0)
                {
                    y = y1 + ((y2 - y1) * (cx1 - x1)) / (x2 - x1);
                    x = cx1;
                }
                else if ((c & 2) != 0)
                {
                    y = y1 + ((y2 - y1) * (cx2 - x1)) / (x2 - x1);
                    x = cx2;
                }
                else if (y1 == y2)
                {
                    if (x2 < cx1)
                        x = cx1;
                    else if (x2 > cx2)
                        x = cx2;
                    if (x1 < cx1)
                        x = cx1;
                    else if (x1 > cx2)
                        x = cx2;
                    y = y1;
                }
                else if ((c & 4) != 0)
                {
                    x = x1 + ((x2 - x1) * (cy1 - y1)) / (y2 - y1);
                    y = cy1;
                }
                else if ((c & 8) != 0)
                {
                    x = x1 + ((x2 - x1) * (cy2 - y1)) / (y2 - y1);
                    y = cy2;
                }
                if (c == c1)
                {
                    x1 = x;
                    y1 = y;
                    c1 = Make_4bit_code(x, y, cx1, cy1, cx2, cy2);
                }
                else
                {
                    x2 = x;
                    y2 = y;
                    c2 = Make_4bit_code(x, y, cx1, cy1, cx2, cy2);
                }
            }

            return null;
        }

        public Segment3D Vs_line_clip_3df(Segment3D seg)
        {
            double xs = seg.p0.x;
            double ys = seg.p0.y;
            double zs = seg.p0.z;
            double xe = seg.p1.x;
            double ye = seg.p1.y;
            double ze = seg.p1.z;
            Segment3D ret = new Segment3D();
            double x0;
            double y0;
            double z0;
            double x1;
            double y1;
            double z1;
            if (zs <= ze)
            {
                x0 = xs;
                y0 = ys;
                z0 = zs;
                x1 = xe;
                y1 = ye;
                z1 = ze;
            }
            else
            {
                x0 = xe;
                y0 = ye;
                z0 = ze;
                x1 = xs;
                y1 = ys;
                z1 = zs;
            }
            if (z1 < 0.10000000000000001D)
                return null;
            if (z0 >= 0.10000000000000001D)
            {
                ret.SetP0(new Vector3D(seg.p0));
                ret.SetP1(new Vector3D(seg.p1));
                return ret;
            }
            else
            {
                double t = (0.10000000000000001D - z0) / (z1 - z0);
                x0 += t * (x1 - x0);
                y0 += t * (y1 - y0);
                z0 = 0.10000000000000001D;
                ret.SetP0(new Vector3D(x0, y0, z0));
                ret.SetP1(new Vector3D(x1, y1, z1));
                return ret;
            }
        }

        public Vector3D Vs_point_clip_3df(Vector3D v)
        {
            if (v.z < 0.10000000000000001D)
                return null;
            else
                return new Vector3D(v);
        }

        public Vector3D Vs_point_clip2d(Vector3D v)
        {
            if (v.x < vp_xmin || v.x > vp_xmax || v.y < vp_ymin || v.y > vp_ymax)
            {
                return null;
            }
            else
            {
                Vector3D ret = new Vector3D(v);
                ret.z = 0.0D;
                return ret;
            }
        }

        public Polygon3D Vs_polygon_clip_2d(Polygon3D poly)
        {
            Polygon3D s = new Polygon3D();
            Polygon3D r = new Polygon3D();
            double vxmin = vp_xmin - 0.40000000000000002D;
            double vymin = vp_ymin - 0.40000000000000002D;
            double vxmax = vp_xmax + 0.40000000000000002D;
            double vymax = vp_ymax + 0.40000000000000002D;
            s.SetPol(poly);
            double xmin = poly.XMin();
            double xmax = poly.XMax();
            double ymin = poly.YMin();
            double ymax = poly.YMax();
            if (xmax < vxmin || xmin > vxmax || ymax < vymin || ymin > vymax)
                return r;
            if (xmin >= vxmin && xmax <= vxmax && ymin >= vymin && ymax <= vymax)
            {
                r.SetPol(poly);
                return r;
            }
            if (xmin >= vxmin)
            {
                r.SetPol(s);
            }
            else
            {
                for (int i = 0; i < s.NVertex(); i++)
                {
                    int j;
                    if (i == s.NVertex() - 1)
                        j = 0;
                    else
                        j = i + 1;
                    double xi = s.GetVertex(i).x;
                    double yi = s.GetVertex(i).y;
                    double xj = s.GetVertex(j).x;
                    double yj = s.GetVertex(j).y;
                    if (xi >= vxmin)
                    {
                        r.AddVertex(new Vector3D(xi, yi, 0.0D));
                        if (xj < vxmin)
                            r.AddVertex(new Vector3D(vxmin, yi
                                    + ((yj - yi) * (vxmin - xi)) / (xj - xi), 0.0D));
                    }
                    else if (xj >= vxmin)
                        r.AddVertex(new Vector3D(vxmin, yi
                                + ((yj - yi) * (vxmin - xi)) / (xj - xi), 0.0D));
                }

            }
            s = new Polygon3D();
            if (ymin >= vymin)
            {
                s.SetPol(r);
            }
            else
            {
                for (int i_0 = 0; i_0 < r.NVertex(); i_0++)
                {
                    int j_1;
                    if (i_0 == r.NVertex() - 1)
                        j_1 = 0;
                    else
                        j_1 = i_0 + 1;
                    double xi_2 = r.GetVertex(i_0).x;
                    double yi_3 = r.GetVertex(i_0).y;
                    double xj_4 = r.GetVertex(j_1).x;
                    double yj_5 = r.GetVertex(j_1).y;
                    if (yi_3 >= vymin)
                    {
                        s.AddVertex(new Vector3D(xi_2, yi_3, 0.0D));
                        if (yj_5 < vymin)
                            s.AddVertex(new Vector3D(xi_2 + ((xj_4 - xi_2) * (vymin - yi_3)) / (yj_5 - yi_3), vymin, 0.0D));
                    }
                    else if (yj_5 >= vymin)
                        s.AddVertex(new Vector3D(xi_2 + ((xj_4 - xi_2) * (vymin - yi_3)) / (yj_5 - yi_3), vymin, 0.0D));
                }

            }
            r = new Polygon3D();
            if (xmax <= vxmax)
            {
                r.SetPol(s);
            }
            else
            {
                for (int i_6 = 0; i_6 < s.NVertex(); i_6++)
                {
                    int j_7;
                    if (i_6 == s.NVertex() - 1)
                        j_7 = 0;
                    else
                        j_7 = i_6 + 1;
                    double xi_8 = s.GetVertex(i_6).x;
                    double yi_9 = s.GetVertex(i_6).y;
                    double xj_10 = s.GetVertex(j_7).x;
                    double yj_11 = s.GetVertex(j_7).y;
                    if (xi_8 <= vxmax)
                    {
                        r.AddVertex(new Vector3D(xi_8, yi_9, 0.0D));
                        if (xj_10 > vxmax)
                            r.AddVertex(new Vector3D(vxmax, yi_9 + ((yj_11 - yi_9) * (vxmax - xi_8)) / (xj_10 - xi_8), 0.0D));
                    }
                    else if (xj_10 <= vxmax)
                        r.AddVertex(new Vector3D(vxmax, yi_9 + ((yj_11 - yi_9) * (vxmax - xi_8)) / (xj_10 - xi_8), 0.0D));
                }

            }
            s = new Polygon3D();
            if (ymax <= vymax)
            {
                s.SetPol(r);
            }
            else
            {
                for (int i_12 = 0; i_12 < r.NVertex(); i_12++)
                {
                    int j_13;
                    if (i_12 == r.NVertex() - 1)
                        j_13 = 0;
                    else
                        j_13 = i_12 + 1;
                    double xi_14 = r.GetVertex(i_12).x;
                    double yi_15 = r.GetVertex(i_12).y;
                    double xj_16 = r.GetVertex(j_13).x;
                    double yj_17 = r.GetVertex(j_13).y;
                    if (yi_15 <= vymax)
                    {
                        s.AddVertex(new Vector3D(xi_14, yi_15, 0.0D));
                        if (yj_17 > vymax)
                            s.AddVertex(new Vector3D(xi_14 + ((xj_16 - xi_14) * (vymax - yi_15)) / (yj_17 - yi_15),
                                    vymax, 0.0D));
                    }
                    else if (yj_17 <= vymax)
                        s.AddVertex(new Vector3D(xi_14 + ((xj_16 - xi_14) * (vymax - yi_15)) / (yj_17 - yi_15), vymax, 0.0D));
                }

            }
            return s;
        }

        public Polygon3D Vs_polygon_clip_3df(Polygon3D poly)
        {
            Polygon3D s = new Polygon3D();
            Polygon3D r = new Polygon3D();
            s.SetPol(poly);
            double zmin = s.ZMin();
            double zmax = s.ZMax();
            if (zmax < 0.10000000000000001D)
                return r;
            if (zmin >= 0.10000000000000001D)
            {
                r.SetPol(poly);
                return r;
            }
            for (int i = 0; i < s.NVertex(); i++)
            {
                int j;
                if (i == s.NVertex() - 1)
                    j = 0;
                else
                    j = i + 1;
                double xi = s.GetVertex(i).x;
                double yi = s.GetVertex(i).y;
                double zi = s.GetVertex(i).z;
                double xj = s.GetVertex(j).x;
                double yj = s.GetVertex(j).y;
                double zj = s.GetVertex(j).z;
                if (zi >= 0.10000000000000001D)
                {
                    r.AddVertex(new Vector3D(xi, yi, zi));
                    if (zj < 0.10000000000000001D)
                    {
                        double t = (0.10000000000000001D - zi) / (zj - zi);
                        r.AddVertex(new Vector3D(xi + (xj - xi) * t, yi + (yj - yi) * t, 0.10000000000000001D));
                    }
                }
                else if (zj >= 0.10000000000000001D)
                {
                    double t_0 = (0.10000000000000001D - zi) / (zj - zi);
                    r.AddVertex(new Vector3D(xi + (xj - xi) * t_0, yi + (yj - yi) * t_0, 0.10000000000000001D));
                }
            }

            return r;
        }
    }
}